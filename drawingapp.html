<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing Canvas with Block Code Image</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f6f8;
            font-family: Arial, sans-serif;
        }
        #header {
            text-align: center;
            padding: 20px;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            margin: 20px;
            max-width: 80%;
        }
        h1 {
            font-family: 'Roboto', sans-serif;
            font-size: 2.5em;
            color: #2c3e50;
            margin: 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        #header p {
            font-size: 1.1em;
            color: #34495e;
            margin: 10px 0 0;
            line-height: 1.5;
            background-color: #e8f0fe;
            padding: 10px;
            border-radius: 5px;
        }
        #container {
            display: flex;
            gap: 20px;
            margin: 20px;
        }
        #canvas-container {
            border: 1px solid #ccc;
            background-color: white;
            position: relative;
        }
        #toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        button, select {
            padding: 8px 12px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        button:hover, select:hover {
            background-color: #e0e0e0;
        }
        #color-picker {
            width: 40px;
            height: 30px;
            cursor: pointer;
            border: none;
        }
        #image-panel {
            width: 300px;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
        }
        #block-code-image {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        #playback-controls {
            display: none;
            gap: 10px;
            margin-top: 10px;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Drawing Canvas for Block Code</h1>
        <p>Upload or paste an image of block-based code (e.g., Scratch, Blockly) to display alongside the canvas. Draw its logic using flowcharts or diagrams. Features include drawing tools, shapes, text, undo/redo, save as PNG, zoom, and recording/playback.</p>
    </div>
    
    <div id="toolbar">
        <label for="tool-select">Tool:</label>
        <select id="tool-select">
            <option value="pen">Pen</option>
            <option value="eraser">Eraser</option>
            <option value="line">Line</option>
            <option value="rectangle">Rectangle</option>
            <option value="circle">Circle</option>
            <option value="arrow">Arrow</option>
            <option value="text">Text</option>
        </select>
        
        <label for="color-picker">Color:</label>
        <input type="color" id="color-picker" value="#000000">
        
        <label for="line-width">Line Width:</label>
        <input type="range" id="line-width" min="1" max="20" value="5">
        
        <button id="undo-btn">Undo</button>
        <button id="redo-btn">Redo</button>
        
        <button id="clear-btn">Clear Canvas</button>
        <button id="save-png-btn">Save as PNG</button>
        
        <button id="record-btn">Start Recording</button>
    </div>
    
    <div id="container">
        <div id="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <div id="image-panel">
            <h3>Block Code Image</h3>
            <input type="file" id="image-upload" accept="image/*">
            <p>Paste image from clipboard or click to upload.</p>
            <img id="block-code-image" src="" alt="Block-based code image">
        </div>
    </div>
    
    <div id="playback-controls">
        <button id="play-btn">Play</button>
        <button id="pause-btn">Pause</button>
        <button id="stop-btn">Stop</button>
        <label for="playback-speed">Speed:</label>
        <input type="range" id="playback-speed" min="0.5" max="2" step="0.1" value="1">
    </div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const toolSelect = document.getElementById('tool-select');
        const colorPicker = document.getElementById('color-picker');
        const lineWidthSlider = document.getElementById('line-width');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const clearBtn = document.getElementById('clear-btn');
        const savePngBtn = document.getElementById('save-png-btn');
        const imageUpload = document.getElementById('image-upload');
        const blockCodeImage = document.getElementById('block-code-image');
        const recordBtn = document.getElementById('record-btn');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const playbackSpeed = document.getElementById('playback-speed');
        const playbackControls = document.getElementById('playback-controls');
        
        let drawing = false;
        let currentTool = 'pen';
        let startX, startY, lastX, lastY;
        let history = [];
        let redoStack = [];
        let actions = [];
        let recording = false;
        let playing = false;
        let playbackIndex = 0;
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        // Initialize canvas
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = lineWidthSlider.value;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        saveState();
        
        // Event listeners for canvas
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('wheel', handleZoom);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('touchend', stopDrawing);
        
        // Tool selection
        toolSelect.addEventListener('change', () => {
            currentTool = toolSelect.value;
            canvas.style.cursor = currentTool === 'text' ? 'text' : 'crosshair';
        });
        
        // Color and line width
        colorPicker.addEventListener('input', () => {
            ctx.strokeStyle = colorPicker.value;
            ctx.fillStyle = colorPicker.value;
        });
        
        lineWidthSlider.addEventListener('input', () => {
            ctx.lineWidth = lineWidthSlider.value;
        });
        
        // Undo/Redo
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        
        // Clear canvas
        clearBtn.addEventListener('click', clearCanvas);
        
        // Save as PNG
        savePngBtn.addEventListener('click', saveAsPng);
        
        // Image upload and paste
        imageUpload.addEventListener('change', handleImageUpload);
        document.addEventListener('paste', handlePaste);
        
        // Recording and playback
        recordBtn.addEventListener('click', toggleRecording);
        playBtn.addEventListener('click', startPlayback);
        pauseBtn.addEventListener('click', pausePlayback);
        stopBtn.addEventListener('click', stopPlayback);
        
        function getPosition(e) {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            if (e.touches) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            x = (x - translateX) / scale;
            y = (y - translateY) / scale;
            return [x, y];
        }
        
        function startDrawing(e) {
            if (playing) return;
            drawing = true;
            [startX, startY] = getPosition(e);
            lastX = startX;
            lastY = startY;
            if (currentTool === 'text') {
                const text = prompt('Enter text:');
                if (text) {
                    ctx.font = `${lineWidthSlider.value * 5}px Arial`;
                    ctx.fillText(text, startX, startY);
                    saveState();
                    recordAction({ type: 'text', x: startX, y: startY, text, font: ctx.font, fillStyle: ctx.fillStyle });
                }
                drawing = false;
            } else if (currentTool !== 'pen' && currentTool !== 'eraser') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            }
        }
        
        function draw(e) {
            if (!drawing || playing) return;
            e.preventDefault();
            const [x, y] = getPosition(e);
            ctx.save();
            ctx.translate(translateX, translateY);
            ctx.scale(scale, scale);
            if (currentTool === 'pen') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                recordAction({ type: 'pen', fromX: lastX, fromY: lastY, toX: x, toY: y, strokeStyle: ctx.strokeStyle, lineWidth: ctx.lineWidth });
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
                recordAction({ type: 'eraser', fromX: lastX, fromY: lastY, toX: x, toY: y, lineWidth: ctx.lineWidth });
            }
            ctx.restore();
            lastX = x;
            lastY = y;
            drawCanvas();
        }
        
        function stopDrawing() {
            if (!drawing || playing) return;
            drawing = false;
            if (currentTool === 'line' || currentTool === 'rectangle' || currentTool === 'circle' || currentTool === 'arrow') {
                ctx.save();
                ctx.translate(translateX, translateY);
                ctx.scale(scale, scale);
                ctx.beginPath();
                if (currentTool === 'line') {
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(lastX, lastY);
                    ctx.stroke();
                    recordAction({ type: 'line', startX, startY, endX: lastX, endY: lastY, strokeStyle: ctx.strokeStyle, lineWidth: ctx.lineWidth });
                } else if (currentTool === 'rectangle') {
                    ctx.strokeRect(startX, startY, lastX - startX, lastY - startY);
                    recordAction({ type: 'rectangle', x: startX, y: startY, width: lastX - startX, height: lastY - startY, strokeStyle: ctx.strokeStyle, lineWidth: ctx.lineWidth });
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt((lastX - startX) ** 2 + (lastY - startY) ** 2);
                    ctx.beginPath();
                    ctx.arc(startX, startY, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    recordAction({ type: 'circle', x: startX, y: startY, radius, strokeStyle: ctx.strokeStyle, lineWidth: ctx.lineWidth });
                } else if (currentTool === 'arrow') {
                    drawArrow(startX, startY, lastX, lastY);
                    recordAction({ type: 'arrow', startX, startY, endX: lastX, endY: lastY, strokeStyle: ctx.strokeStyle, lineWidth: ctx.lineWidth });
                }
                ctx.restore();
                saveState();
            } else {
                saveState();
            }
        }
        
        function drawArrow(fromX, fromY, toX, toY) {
            const headLength = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.lineTo(toX, toY);
            ctx.fill();
        }
        
        function drawCanvas() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(translateX, translateY);
            ctx.scale(scale, scale);
            const imgData = history[history.length - 1];
            if (imgData) ctx.putImageData(imgData, 0, 0);
            ctx.restore();
        }
        
        function saveState() {
            history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            redoStack = [];
            drawCanvas();
        }
        
        function undo() {
            if (history.length > 1) {
                redoStack.push(history.pop());
                drawCanvas();
            }
        }
        
        function redo() {
            if (redoStack.length > 0) {
                history.push(redoStack.pop());
                drawCanvas();
            }
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveState();
            recordAction({ type: 'clear' });
        }
        
        function saveAsPng() {
            const link = document.createElement('a');
            link.download = 'drawing.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
        
        function handleZoom(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            scale += delta;
            scale = Math.max(0.5, Math.min(scale, 3));
            drawCanvas();
        }
        
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    blockCodeImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        function handlePaste(e) {
            const items = e.clipboardData.items;
            for (const item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        blockCodeImage.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
            }
        }
        
        function recordAction(action) {
            if (recording) {
                actions.push({ ...action, timestamp: Date.now() });
            }
        }
        
        function toggleRecording() {
            recording = !recording;
            recordBtn.textContent = recording ? 'Stop Recording' : 'Start Recording';
            if (recording) {
                actions = [];
                playbackControls.style.display = 'none';
            } else {
                playbackControls.style.display = 'flex';
            }
        }
        
        function redrawActions() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(translateX, translateY);
            ctx.scale(scale, scale);
            actions.forEach(action => {
                ctx.save();
                if (action.strokeStyle) ctx.strokeStyle = action.strokeStyle;
                if (action.fillStyle) ctx.fillStyle = action.fillStyle;
                if (action.lineWidth) ctx.lineWidth = action.lineWidth;
                if (action.font) ctx.font = action.font;
                if (action.type === 'pen' || action.type === 'eraser') {
                    if (action.type === 'eraser') ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.moveTo(action.fromX, action.fromY);
                    ctx.lineTo(action.toX, action.toY);
                    ctx.stroke();
                    if (action.type === 'eraser') ctx.globalCompositeOperation = 'source-over';
                } else if (action.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(action.startX, action.startY);
                    ctx.lineTo(action.endX, action.endY);
                    ctx.stroke();
                } else if (action.type === 'rectangle') {
                    ctx.strokeRect(action.x, action.y, action.width, action.height);
                } else if (action.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(action.x, action.y, action.radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (action.type === 'arrow') {
                    drawArrow(action.startX, action.startY, action.endX, action.endY);
                } else if (action.type === 'text') {
                    ctx.fillText(action.text, action.x, action.y);
                } else if (action.type === 'clear') {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
                ctx.restore();
            });
            ctx.restore();
            drawCanvas();
        }
        
        function startPlayback() {
            if (actions.length === 0) return;
            playing = true;
            playbackIndex = 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            history = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            animatePlayback();
        }
        
        function animatePlayback() {
            if (!playing || playbackIndex >= actions.length) {
                playing = false;
                playbackControls.style.display = 'flex';
                return;
            }
            const action = actions[playbackIndex];
            ctx.save();
            ctx.translate(translateX, translateY);
            ctx.scale(scale, scale);
            ctx.strokeStyle = action.strokeStyle || ctx.strokeStyle;
            ctx.fillStyle = action.fillStyle || ctx.fillStyle;
            ctx.lineWidth = action.lineWidth || ctx.lineWidth;
            if (action.font) ctx.font = action.font;
            if (action.type === 'pen' || action.type === 'eraser') {
                if (action.type === 'eraser') ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.moveTo(action.fromX, action.fromY);
                ctx.lineTo(action.toX, action.toY);
                ctx.stroke();
                if (action.type === 'eraser') ctx.globalCompositeOperation = 'source-over';
            } else if (action.type === 'line') {
                ctx.beginPath();
                ctx.moveTo(action.startX, action.startY);
                ctx.lineTo(action.endX, action.endY);
                ctx.stroke();
            } else if (action.type === 'rectangle') {
                ctx.strokeRect(action.x, action.y, action.width, action.height);
            } else if (action.type === 'circle') {
                ctx.beginPath();
                ctx.arc(action.x, action.y, action.radius, 0, Math.PI * 2);
                ctx.stroke();
            } else if (action.type === 'arrow') {
                drawArrow(action.startX, action.startY, action.endX, action.endY);
            } else if (action.type === 'text') {
                ctx.fillText(action.text, action.x, action.y);
            } else if (action.type === 'clear') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            ctx.restore();
            drawCanvas();
            playbackIndex++;
            setTimeout(animatePlayback, 100 / playbackSpeed.value);
        }
        
        function pausePlayback() {
            playing = false;
        }
        
        function stopPlayback() {
            playing = false;
            playbackIndex = 0;
            redrawActions();
        }
    </script>
</body>
</html>
